package camzup.core;

import java.io.File;

import javax.xml.XMLConstants;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;

import org.w3c.dom.Document;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Iterator;
import java.util.LinkedList;

/**
 * A scalable vector graphics (SVG) parser class. SVG parsing is at best
 * <em>very</em> minimal. Use only for basic or simplified SVG files, not
 * ones that contain CSS styling (color and materials will not be evaluated
 * anyways) or non-standard XML nodes (including nodes generated by
 * Inkscape and/or Adobe Illustrator).
 */
public abstract class ParserSvg {

   /**
    * Private constructor for abstract class.
    */
   private ParserSvg ( ) {}

   /**
    * Ratio to convert from centimeters to units,
    * {@value ParserSvg#CM_TO_UNIT}. In Processing, the value was 35.43307 .
    */
   public static final float CM_TO_UNIT = 37.795f;

   /**
    * Ratio to convert from gradians to radians,
    * {@value ParserSvg#GRAD_TO_RAD}.
    */
   public static final float GRAD_TO_RAD = 0.015708f;

   /**
    * Ratio to convert from inches to units, {@value ParserSvg#IN_TO_UNIT}. In
    * Processing, the value was 90.0 .
    */
   public static final float IN_TO_UNIT = 96.0f;

   /**
    * Ratio to convert from millimeters to units,
    * {@value ParserSvg#MM_TO_UNIT}. In Processing, the value was 3.543307 .
    */
   public static final float MM_TO_UNIT = 3.7795f;

   /**
    * Ratio to convert from picas to units, {@value ParserSvg#PC_TO_UNIT}. In
    * Processing, the value was 15.0 .
    */
   public static final float PC_TO_UNIT = 16.0f;

   /**
    * Ratio to convert from points to units, {@value ParserSvg#PT_TO_UNIT}. In
    * Processing the value was 1.25 .
    */
   public static final float PT_TO_UNIT = IUtils.FOUR_THIRDS;

   /**
    * Ratio to convert from pixels to units, {@value ParserSvg#PX_TO_UNIT}.
    */
   public static final float PX_TO_UNIT = 1.0f;

   /**
    * For use in parsing arcs to between points, one divided by \u03c0 ,
    * approximately {@value ParserSvg#TWO_DIV_PI} .
    */
   public static final float TWO_DIV_PI = 0.63661975f;

   /**
    * Characters used to represent a command in an SVG path. Sorted in natural
    * order, where capital letters precede lower-case letters.
    */
   private static final char[] CMDS = { 'A', 'C', 'H', 'L', 'M', 'Q', 'S', 'T',
      'V', 'Z', 'a', 'c', 'h', 'l', 'm', 'q', 's', 't', 'v', 'z' };

   /**
    * Given a file path, parses an SVG and returns a curve entity.
    *
    * @param fileName the file name
    *
    * @return the curve entity
    */
   public static CurveEntity2 load ( final String fileName ) {

      final CurveEntity2 result = new CurveEntity2();

      try {

         /*
          * Sonar lint security complaint recommends these settings. This will
          * cause <?xml> tags at the start of the SVG to throw an error.
          */
         final DocumentBuilderFactory df = DocumentBuilderFactory.newInstance();
         df.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, "");
         df.setAttribute(XMLConstants.ACCESS_EXTERNAL_SCHEMA, "");
         final DocumentBuilder db = df.newDocumentBuilder();
         final File file = new File(fileName);
         final Document doc = db.parse(file);
         doc.normalizeDocument();

         /*
          * Because nodes are hierarchical and transformations compound upon
          * transformations, a stack is needed (a double-ended que is the
          * closest in Java).
          */
         final Mat3 curr = new Mat3();
         final Mat3 delta = new Mat3();
         final LinkedList < Mat3 > matStack = new LinkedList <>();
         matStack.push(Mat3.identity(new Mat3()));

         final ArrayList < Curve2 > curves = new ArrayList <>();

         final Node header = doc.getFirstChild();
         final NodeList nodes = header.getChildNodes();
         final int nodeLen = nodes.getLength();
         for ( int i = 0; i < nodeLen; ++i ) {
            ParserSvg.parseNode(nodes.item(i), matStack, curr, delta, curves);
         }

         result.appendAll(curves);

      } catch ( final Exception e ) {
         e.printStackTrace();
      }

      return result;
   }

   /**
    * Parses a flag to a boolean
    *
    * @param v the flag string
    *
    * @return the boolean
    */
   public static boolean parseFlag ( final String v ) {

      int x = 0;
      try {
         x = Integer.parseInt(v, 10);
      } catch ( final Exception e ) {
         x = 0;
      }
      return x != 0;
   }

   /**
    * A helper function to parse an angle to radians. The default is assumed
    * to be degrees.
    *
    * @param v   the input value
    * @param def the default
    *
    * @return the angle in radians
    */
   protected static float parseAngle ( final String v, final float def ) {

      float x = def;
      final int len = v.length();
      final int lens3 = len - 3;
      final int lens4 = len - 4;

      try {

         if ( v.startsWith("deg", lens3) ) {

            x = Float.parseFloat(v.substring(0, lens3)) * IUtils.DEG_TO_RAD;

         } else if ( v.startsWith("grad", lens4) ) {

            x = Float.parseFloat(v.substring(0, lens4)) * ParserSvg.GRAD_TO_RAD;

         } else if ( v.startsWith("rad", lens3) ) {

            x = Float.parseFloat(v.substring(0, lens3));

         } else if ( v.startsWith("turn", lens4) ) {

            x = Float.parseFloat(v.substring(0, lens4)) * IUtils.TAU;

         } else {

            /* Degrees is the SVG default. */
            x = Float.parseFloat(v) * IUtils.DEG_TO_RAD;

         }

      } catch ( final Exception e ) { /* Do nothing. */ }

      return x;
   }

   /**
    * Parse a path arc-to command, based on the Processing implementation,
    * which references
    * <a href="http://www.spaceroots.org/documents/ellipse/node22.html">these
    * equations</a>.<br>
    * <br>
    * According to the SVG specification, the large arc flag "is 0 if an arc
    * spanning less than or equal to 180 degrees is chosen, or 1 if an arc
    * spanning greater than 180 degrees is chosen".<br>
    * <br>
    * The sweep flag "is 0 if the line joining center to arc sweeps through
    * decreasing angles, or 1 if it sweeps through increasing angles".
    *
    * @param prior    the prior knot
    * @param major    the major axis
    * @param minor    the minor axis
    * @param ang      the angle
    * @param largeArc large arc flag
    * @param sweep    sweep flag
    * @param xDest    destination x
    * @param yDest    destination y
    *
    * @return an array of knots
    */
   protected static Knot2[] parseArcTo ( final Knot2 prior, final float major,
      final float minor, final float ang, final boolean largeArc,
      final boolean sweep, final float xDest, final float yDest ) {

      if ( Utils.approx(prior.coord.x, xDest) && Utils.approx(prior.coord.y,
         yDest) || major < IUtils.EPSILON || minor < IUtils.EPSILON ) {
         return new Knot2[] { new Knot2(xDest, yDest) };
      }

      /* Valid major and minor axes. */
      float rx = Utils.abs(major);
      float ry = Utils.abs(minor);

      /* Wrap the angle into range, find sine and cosine. */
      final float phi = Utils.mod1(ang * IUtils.ONE_TAU);
      final float cosPhi = Utils.scNorm(phi);
      final float sinPhi = Utils.scNorm(phi - 0.25f);

      final float x1 = prior.coord.x;
      final float y1 = prior.coord.y;

      final float xDiff = x1 - xDest;
      final float yDiff = y1 - yDest;

      /* Apply phi rotation to difference. */
      final float x1r = 0.5f * ( cosPhi * xDiff + sinPhi * yDiff );
      final float y1r = 0.5f * ( cosPhi * yDiff - sinPhi * xDiff );

      /* Square the rotation. */
      final float x1rsq = x1r * x1r;
      final float y1rsq = y1r * y1r;

      /* Square the major and minor axes. */
      final float rxsq = rx * rx;
      final float rysq = ry * ry;

      float cxr = 0.0f;
      float cyr = 0.0f;
      final float a = x1rsq / rxsq + y1rsq / rysq;
      if ( a > 1.0f ) {
         final float sqrta = Utils.sqrtUnchecked(a);
         rx *= sqrta;
         ry *= sqrta;
      } else {
         final float denom = rxsq * y1rsq + rysq * x1rsq;
         float k = Utils.sqrtUnchecked(rxsq * rysq / denom - 1.0f);
         k = largeArc == sweep ? -k : k;
         cxr = k * rx * y1r / ry;
         cyr = -k * ry * x1r / rx;
      }

      final float cx = cosPhi * cxr - sinPhi * cyr + 0.5f * ( x1 + xDest );
      final float cy = sinPhi * cxr + cosPhi * cyr + 0.5f * ( y1 + yDest );

      final float rxInv = 1.0f / rx;
      final float ryInv = 1.0f / ry;
      final float sx = ( x1r - cxr ) * rxInv;
      final float sy = ( y1r - cyr ) * ryInv;
      final float tx = ( -x1r - cxr ) * rxInv;
      final float ty = ( -y1r - cyr ) * ryInv;

      final float phi1 = Utils.atan2(sy, sx);

      float phiDelta = Utils.modRadians(Utils.atan2(ty, tx) - phi1);
      if ( !sweep ) { phiDelta -= IUtils.TAU; }

      final float phiNorm = Utils.mod1(phi1 * IUtils.ONE_TAU);
      final float cosPhi1 = Utils.scNorm(phiNorm);
      final float sinPhi1 = Utils.scNorm(phiNorm - 0.25f);

      final int segCount = Utils.ceil(Utils.abs(phiDelta)
         * ParserSvg.TWO_DIV_PI);
      final float incr = phiDelta / segCount;
      final float tanIncr = Utils.tan(incr * 0.5f);
      final float handle = Utils.sqrt(4.0f + 3.0f * tanIncr * tanIncr) - 1.0f;
      final float b = Utils.sin(incr) * handle * IUtils.ONE_THIRD;

      /* To determine when to wrap to initial point. */
      final int segLast = segCount - 1;

      /* Changed within for loop. */
      float rxSinEta = -rx * sinPhi1;
      float ryCosEta = ry * cosPhi1;
      float fhxPrev = b * ( rxSinEta * cosPhi - ryCosEta * sinPhi );
      float fhyPrev = b * ( rxSinEta * sinPhi + ryCosEta * cosPhi );
      float coxPrev = x1;
      float coyPrev = y1;
      float j = 1.0f;

      final Knot2[] kns = new Knot2[segCount];
      Knot2 prev = prior;

      for ( int i = 0; i < segCount; ++i ) {

         final float eta = phi1 + j * incr;
         final float cosEta = Utils.cos(eta);
         final float sinEta = Utils.sin(eta);

         rxSinEta = -rx * sinEta;
         ryCosEta = ry * cosEta;

         final float rhxCurr = b * ( rxSinEta * cosPhi - ryCosEta * sinPhi );
         final float rhyCurr = b * ( rxSinEta * sinPhi + ryCosEta * cosPhi );

         float coxCurr = xDest;
         float coyCurr = yDest;
         if ( i != segLast ) {
            final float rxCosEta = rx * cosEta;
            final float rySinEta = ry * sinEta;
            coxCurr = cx + cosPhi * rxCosEta - sinPhi * rySinEta;
            coyCurr = cy + sinPhi * rxCosEta + cosPhi * rySinEta;
         }

         prev.foreHandle.set(coxPrev + fhxPrev, coyPrev + fhyPrev);

         final Knot2 curr = new Knot2(coxCurr, coyCurr, coxCurr + rhxCurr,
            coyCurr + rhyCurr, coxCurr - rhxCurr, coyCurr - rhyCurr);
         kns[i] = curr;

         /* Update references. */
         prev = curr;
         coxPrev = coxCurr;
         fhxPrev = rhxCurr;
         coyPrev = coyCurr;
         fhyPrev = rhyCurr;
         ++j;
      }

      return kns;
   }

   /**
    * Parses a SVG node and returns a Curve2 approximating a circle.
    *
    * @param ellipseNode the ellipse node
    * @param target      the output curve
    *
    * @return the ellipse curve
    */
   protected static Curve2 parseEllipse ( final Node ellipseNode,
      final Curve2 target ) {

      final NamedNodeMap attributes = ellipseNode.getAttributes();
      if ( attributes != null ) {

         /* Search for attribute nodes. May return null. */
         final Node cxNode = attributes.getNamedItem("cx");
         final Node cyNode = attributes.getNamedItem("cy");
         Node rxNode = attributes.getNamedItem("rx");
         Node ryNode = attributes.getNamedItem("ry");

         /*
          * One or other of the ellipse's axes could be missing, or this node
          * could be circle.
          */
         if ( ryNode != null && rxNode == null ) { rxNode = ryNode; }
         if ( rxNode != null && ryNode == null ) { ryNode = rxNode; }
         if ( rxNode == null && ryNode == null ) {
            rxNode = ryNode = attributes.getNamedItem("r");
         }

         /* Acquire text content from the node if it exists. */
         final String cxStr = cxNode != null ? cxNode.getNodeValue() : "0";
         final String cyStr = cyNode != null ? cyNode.getNodeValue() : "0";
         final String rxStr = rxNode != null ? rxNode.getNodeValue() : "0.5";
         final String ryStr = ryNode != null ? ryNode.getNodeValue() : "0.5";

         /* Parse string or default. */
         final float cx = ParserSvg.parsef(cxStr, 0.0f);
         final float cy = ParserSvg.parsef(cyStr, 0.0f);
         final float rx = ParserSvg.parsef(rxStr, 0.5f);
         final float ry = ParserSvg.parsef(ryStr, 0.5f);

         /* Find cardinal control points. */
         final float right = cx + rx;
         final float top = cy + ry;
         final float left = cx - rx;
         final float bottom = cy - ry;

         final float horizHandle = rx * ICurve.HNDL_MAG_ORTHO;
         final float vertHandle = ry * ICurve.HNDL_MAG_ORTHO;

         final float xHandlePos = cx + horizHandle;
         final float xHandleNeg = cx - horizHandle;

         final float yHandlePos = cy + vertHandle;
         final float yHandleNeg = cy - vertHandle;

         /* Resize and acquire four knots. */
         target.resize(4);
         final Iterator < Knot2 > itr = target.iterator();
         target.closedLoop = true;

         itr.next().set(right, cy, right, yHandlePos, right, yHandleNeg);
         itr.next().set(cx, top, xHandleNeg, top, xHandlePos, top);
         itr.next().set(left, cy, left, yHandleNeg, left, yHandlePos);
         itr.next().set(cx, bottom, xHandlePos, bottom, xHandleNeg, bottom);
      }

      return target;
   }

   /**
    * A helper function to parse real numbers followed by units of measurement
    * in an SVG element. Uses the following conversions:
    * <ul>
    * <li>1 centimeter (cm) = {@value ParserSvg#CM_TO_UNIT} units</li>
    * <li>1 inch (in) = {@value ParserSvg#IN_TO_UNIT} units</li>
    * <li>1 millimeter (mm) = {@value ParserSvg#MM_TO_UNIT} units</li>
    * <li>1 pica (pc) = {@value ParserSvg#PC_TO_UNIT} units</li>
    * <li>1 point (pt) = {@value ParserSvg#PT_TO_UNIT} units</li>
    * <li>1 pixel (px) = {@value ParserSvg#PX_TO_UNIT} units</li>
    * </ul>
    * View box relative units, namely <code>%</code> is limited; all this
    * parser will do is divide the value by 100.<br>
    * <br>
    * Font-relative units, namely <code>em</code> and <code>ex</code> are not
    * supported.
    *
    * @param v   the String value
    * @param def the default value
    *
    * @return the parsed float
    */
   protected static float parsef ( final String v, final float def ) {

      /*
       * The string needs to be trimmed even here because of unconventional
       * formatting which could be contained within a path string.
       */

      float x = def;
      final int len = v.length();
      final int lens1 = len - 1;
      final int lens2 = len - 2;
      final int lens3 = len - 3;

      try {

         if ( v.startsWith("cm", lens2) ) {

            /* Centimeters. */
            x = Float.parseFloat(v.substring(0, lens2)) * ParserSvg.CM_TO_UNIT;

         } else if ( v.startsWith("deg", lens3) ) {

            /* Degrees. */
            x = Float.parseFloat(v.substring(0, lens3)) * IUtils.DEG_TO_RAD;

         } else if ( v.startsWith("in", lens2) ) {

            /* Inches. */
            x = Float.parseFloat(v.substring(0, lens2)) * ParserSvg.IN_TO_UNIT;

         } else if ( v.startsWith("mm", lens2) ) {

            /* Millimeters. */
            x = Float.parseFloat(v.substring(0, lens2)) * ParserSvg.MM_TO_UNIT;

         } else if ( v.startsWith("pc", lens2) ) {

            /* Pica. */
            x = Float.parseFloat(v.substring(0, lens2)) * ParserSvg.PC_TO_UNIT;

         } else if ( v.startsWith("pt", lens2) ) {

            /* Point. */
            x = Float.parseFloat(v.substring(0, lens2)) * ParserSvg.PT_TO_UNIT;

         } else if ( v.startsWith("px", lens2) ) {

            /* Pixel. */
            x = Float.parseFloat(v.substring(0, lens2)) * ParserSvg.PX_TO_UNIT;

         } else if ( v.startsWith("rad", lens3) ) {

            /* Radians. */
            x = Float.parseFloat(v.substring(0, lens3));

         } else if ( v.startsWith("em", lens2) || v.startsWith("ex", lens2) ) {

            /* RELATIVE UNIT: To font size. Not supported in PShape. */
            x = Float.parseFloat(v.substring(0, lens2));

         } else if ( v.startsWith("%", lens1) ) {

            /* RELATIVE UNIT: Simplified from original. */
            x = Float.parseFloat(v.substring(0, lens1)) * 0.01f;

         } else {

            x = Float.parseFloat(v);

         }

      } catch ( final Exception e ) { /* Do nothing. */ }

      return x;
   }

   /**
    * Parses a SVG node and returns a Curve2 forming a line.
    *
    * @param lineNode the line node
    * @param target   the output curve
    *
    * @return the line curve
    */
   protected static Curve2 parseLine ( final Node lineNode,
      final Curve2 target ) {

      final NamedNodeMap attributes = lineNode.getAttributes();
      if ( attributes != null ) {

         /* Search for attribute nodes. May return null. */
         final Node x1Node = attributes.getNamedItem("x1");
         final Node y1Node = attributes.getNamedItem("y1");
         final Node x2Node = attributes.getNamedItem("x2");
         final Node y2Node = attributes.getNamedItem("y2");

         /* Acquire text content from the node if it exists. */
         final String x1Str = x1Node != null ? x1Node.getNodeValue() : "-0.5";
         final String y1Str = y1Node != null ? y1Node.getNodeValue() : "0";
         final String x2Str = x2Node != null ? x2Node.getNodeValue() : "0.5";
         final String y2Str = y2Node != null ? y2Node.getNodeValue() : "0";

         Curve2.line(ParserSvg.parsef(x1Str, -0.5f), ParserSvg.parsef(y1Str,
            0.0f), ParserSvg.parsef(x2Str, 0.5f), ParserSvg.parsef(y2Str, 0.0f),
            target);
      }
      return target;
   }

   /**
    * Parses a node based on its name and attributes. Appends the results to a
    * list of curves. Uses previous matrix and matrix stack to track
    * transforms in groups. Definition nodes are treated as groups.
    *
    * @param node     the node
    * @param matStack the matrix stack
    * @param prev     previous matrix
    * @param delta    the delta matrix
    * @param curves   the curves list
    *
    * @return the curves list
    */
   @Recursive
   protected static ArrayList < Curve2 > parseNode ( final Node node,
      final LinkedList < Mat3 > matStack, final Mat3 prev, final Mat3 delta,
      final ArrayList < Curve2 > curves ) {

      final NamedNodeMap attributes = node.getAttributes();
      if ( attributes != null ) {

         boolean containsTransform = false;
         boolean isGroup = false;
         final Mat3 cumulative = new Mat3(prev);
         final Node transform = attributes.getNamedItem("transform");
         if ( transform != null ) {
            containsTransform = true;
            ParserSvg.parseTransform(transform, cumulative, delta);
            Mat3.mul(matStack.peek(), cumulative, cumulative);
            matStack.push(cumulative);
         }

         Curve2 prim = null;
         ArrayList < Curve2 > path = null;
         final String name = node.getNodeName().toLowerCase();
         final Node idNode = attributes.getNamedItem("id");
         final String id = idNode != null ? idNode.getNodeValue() : name;

         final int hsh = name.hashCode();
         switch ( hsh ) {

            case -1656480802:
               /* "ellipse" */

               prim = ParserSvg.parseEllipse(node, new Curve2(id));
               break;

            case -1360216880:
               /* "circle" */

               prim = ParserSvg.parseEllipse(node, new Curve2(id));
               break;

            case -397519558:
               /* "polygon" */

               prim = ParserSvg.parsePoly(node, new Curve2(id));
               break;

            case 103:
               /* "g" */

               isGroup = true;
               break;

            case 3079438:
               /* "defs" */

               isGroup = true;
               break;

            case 3321844:
               /* "line" */

               prim = ParserSvg.parseLine(node, new Curve2(id));
               break;

            case 3433509:
               /* "path" */
               path = ParserSvg.parsePath(node, id);
               break;

            case 3496420:
               /* "rect" */

               prim = ParserSvg.parseRect(node, new Curve2(id));
               break;

            case 561938880:
               /* "polyline" */

               prim = ParserSvg.parsePoly(node, new Curve2(id));
               break;

            default:
         }

         if ( containsTransform ) { matStack.pop(); }

         /*
          * Node may be a group node, "g", where result is null; a path, which
          * has multiple curves; or a primitive.
          */
         if ( isGroup ) {
            final NodeList children = node.getChildNodes();
            final int childLen = children.getLength();
            for ( int i = 0; i < childLen; ++i ) {
               final Node child = children.item(i);
               ParserSvg.parseNode(child, matStack, cumulative, delta, curves);
            }
         }

         /*
          * Reverse the vertex winding of any primitives from the Zup3 default
          * (CCW) to the SVG default (CW).
          */
         if ( prim != null ) {
            if ( !curves.contains(prim) ) {
               prim.reverse();
               prim.transform(prev);
               curves.add(prim);
            }
         }

         if ( path != null ) {
            final Iterator < Curve2 > itr = path.iterator();
            while ( itr.hasNext() ) {
               final Curve2 pathCurve = itr.next();

               if ( !curves.contains(pathCurve) ) {
                  pathCurve.transform(prev);
                  curves.add(pathCurve);
               }
            }
         }
      }

      return curves;
   }

   /**
    * Parses the data in a path node. Because paths may contain sub-paths,
    * this returns a list of curves.
    *
    * @param pathNode the node
    * @param the      id to name curves
    *
    * @return the list of curves
    */
   protected static ArrayList < Curve2 > parsePath ( final Node pathNode,
      final String name ) {

      final ArrayList < Curve2 > result = new ArrayList <>(2);
      final NamedNodeMap attributes = pathNode.getAttributes();
      if ( attributes != null ) {
         final Node pathData = attributes.getNamedItem("d");
         if ( pathData != null ) {

            /*
             * Break path string down into an array of characters. Loop through
             * it and parse it to path commands. Delimit coordinate instructions
             * by spaces and commas.
             */
            final String pdStr = pathData.getNodeValue();
            final char[] chars = pdStr.toCharArray();
            final int charsLen = chars.length;

            /* Parse path commands. */
            final ArrayList < PathData > paths = new ArrayList <>(16);
            PathData prevData = null;
            for ( int i = 0; i < charsLen; ++i ) {
               // TODO: Will you need to track a previous char just to avoid
               // confusion between unit suffixes and commands?
               final char c = chars[i];
               final int contains = Arrays.binarySearch(ParserSvg.CMDS, c);
               if ( contains > -1 ) {
                  final SvgPathCmd cmd = SvgPathCmd.fromChar(c);
                  final PathData currData = new PathData(cmd, i + 1, charsLen);
                  paths.add(currData);
                  if ( prevData != null ) { prevData.ubDat = i; }
                  prevData = currData;
               }
            }

            /*
             * Usually, one path has one move to command, but in case it
             * doesn't, create a boolean to track an initial move to. If there
             * is more than one, the target curve will be added to the result
             * list and replaced by a new one.
             */
            boolean initialMove = true;

            /* Current curve. */
            Curve2 target = new Curve2(name);
            result.add(target);

            /* Tracks the previous coordinate for relative commands. */
            final Vec2 rel = new Vec2();

            /* For quadratic reflections. */
            final Vec2 midHnd = new Vec2();

            /* Current, previous knots. */
            Knot2 curr = null;
            Knot2 prev = null;

            /* Add data to each instruction. */
            final Iterator < PathData > pathItr = paths.iterator();
            while ( pathItr.hasNext() ) {
               final PathData entry = pathItr.next();
               final SvgPathCmd cmd = entry.cmd;
               final ArrayList < String > data = entry.data;
               ParserSvg.segmentChars(chars, entry.lbDat, entry.ubDat, data);
               final Iterator < String > dataItr = data.iterator();

               switch ( cmd ) {
                  case CLOSE_PATH:

                     target.closedLoop = true;

                     break;

                  case MOVE_TO_ABS:

                     if ( !initialMove ) {
                        if ( target.length() > 1 ) { result.add(target); }
                        target = new Curve2(name);
                     }
                     initialMove = false;

                     curr = new Knot2(ParserSvg.parsef(dataItr.next(), 0.0f),
                        ParserSvg.parsef(dataItr.next(), 0.0f));
                     target.append(curr);

                     //$FALL-THROUGH$
                  case LINE_TO_ABS:

                     while ( dataItr.hasNext() ) {
                        prev = curr;
                        curr = new Knot2();
                        target.append(curr);

                        Knot2.fromSegLinear(ParserSvg.parsef(dataItr.next(),
                           0.0f), ParserSvg.parsef(dataItr.next(), 0.0f), prev,
                           curr);
                     }

                     rel.set(curr.coord);

                     break;

                  case MOVE_TO_REL:

                     if ( !initialMove ) {

                        /* A curve may be empty due to malformed commands. */
                        if ( target.length() > 1 ) {
                           result.add(target);

                           /*
                            * Within a path, multiple sub-paths can use a move
                            * command followed by a close command followed by a
                            * relative move command. This tries to fix offsets.
                            */
                           rel.set(target.closedLoop ? target.getFirst().coord
                              : target.getLast().coord);
                        }

                        target = new Curve2(name);

                     }
                     initialMove = false;

                     curr = new Knot2(rel.x + ParserSvg.parsef(dataItr.next(),
                        0.0f), rel.y + ParserSvg.parsef(dataItr.next(), 0.0f));
                     target.append(curr);

                     //$FALL-THROUGH$
                  case LINE_TO_REL:

                     while ( dataItr.hasNext() ) {
                        rel.set(curr.coord);

                        prev = curr;
                        curr = new Knot2();
                        target.append(curr);

                        Knot2.fromSegLinear(rel.x + ParserSvg.parsef(dataItr
                           .next(), 0.0f), rel.y + ParserSvg.parsef(dataItr
                              .next(), 0.0f), prev, curr);
                     }

                     rel.set(curr.coord);

                     break;

                  case HORIZ_ABS:

                     while ( dataItr.hasNext() ) {
                        prev = curr;
                        curr = new Knot2();
                        target.append(curr);

                        Knot2.fromSegLinear(ParserSvg.parsef(dataItr.next(),
                           0.0f), rel.y, prev, curr);

                        rel.set(curr.coord);
                     }

                     break;

                  case HORIZ_REL:

                     while ( dataItr.hasNext() ) {
                        prev = curr;
                        curr = new Knot2();
                        target.append(curr);

                        Knot2.fromSegLinear(rel.x + ParserSvg.parsef(dataItr
                           .next(), 0.0f), rel.y, prev, curr);

                        rel.set(curr.coord);
                     }

                     break;

                  case VERT_ABS:

                     while ( dataItr.hasNext() ) {
                        prev = curr;
                        curr = new Knot2();
                        target.append(curr);

                        Knot2.fromSegLinear(rel.x, ParserSvg.parsef(dataItr
                           .next(), 0.0f), prev, curr);

                        rel.set(curr.coord);
                     }

                     break;

                  case VERT_REL:

                     while ( dataItr.hasNext() ) {
                        prev = curr;
                        curr = new Knot2();
                        target.append(curr);

                        Knot2.fromSegLinear(rel.x, rel.y + ParserSvg.parsef(
                           dataItr.next(), 0.0f), prev, curr);

                        rel.set(curr.coord);
                     }

                     break;

                  case QUADRATIC_TO_ABS:

                     while ( dataItr.hasNext() ) {
                        prev = curr;
                        curr = new Knot2();
                        target.append(curr);

                        /*
                         * Mid-handle needs to be set to record quadratic in
                         * case reflection is used next.
                         */
                        midHnd.set(ParserSvg.parsef(dataItr.next(), 0.0f),
                           ParserSvg.parsef(dataItr.next(), 0.0f));
                        curr.coord.set(ParserSvg.parsef(dataItr.next(), 0.0f),
                           ParserSvg.parsef(dataItr.next(), 0.0f));

                        Curve2.lerp13(midHnd, prev.coord, prev.foreHandle);
                        Curve2.lerp13(midHnd, curr.coord, curr.rearHandle);
                     }

                     rel.set(curr.coord);

                     break;

                  case QUADRATIC_TO_REL:

                     while ( dataItr.hasNext() ) {
                        prev = curr;
                        curr = new Knot2();
                        target.append(curr);

                        /*
                         * Mid-handle needs to be set to record quadratic in
                         * case reflection is used next.
                         */
                        midHnd.set(ParserSvg.parsef(dataItr.next(), 0.0f),
                           ParserSvg.parsef(dataItr.next(), 0.0f));
                        curr.coord.set(ParserSvg.parsef(dataItr.next(), 0.0f),
                           ParserSvg.parsef(dataItr.next(), 0.0f));

                        Vec2.add(rel, midHnd, midHnd);
                        Vec2.add(rel, curr.coord, curr.coord);

                        Curve2.lerp13(midHnd, prev.coord, prev.foreHandle);
                        Curve2.lerp13(midHnd, curr.coord, curr.rearHandle);

                        rel.set(curr.coord);
                     }

                     break;

                  case REFLECT_QUADRATIC_ABS:

                     while ( dataItr.hasNext() ) {
                        prev = curr;
                        curr = new Knot2();
                        target.append(curr);

                        prev.mirrorHandlesBackward();
                        curr.coord.set(ParserSvg.parsef(dataItr.next(), 0.0f),
                           ParserSvg.parsef(dataItr.next(), 0.0f));

                        /*
                         * Convert mid-handle from point to direction, negate,
                         * convert back to point.
                         */
                        Vec2.sub(midHnd, prev.coord, midHnd);
                        Vec2.negate(midHnd, midHnd);
                        Vec2.add(midHnd, prev.coord, midHnd);
                        Curve2.lerp13(midHnd, curr.coord, curr.rearHandle);
                     }

                     rel.set(curr.coord);

                     break;

                  case REFLECT_QUADRATIC_REL:

                     while ( dataItr.hasNext() ) {
                        prev = curr;
                        curr = new Knot2();
                        target.append(curr);

                        prev.mirrorHandlesBackward();
                        curr.coord.set(ParserSvg.parsef(dataItr.next(), 0.0f),
                           ParserSvg.parsef(dataItr.next(), 0.0f));
                        Vec2.add(rel, curr.coord, curr.coord);

                        /*
                         * Convert mid-handle from point to direction, negate,
                         * convert back to point.
                         */
                        Vec2.sub(midHnd, prev.coord, midHnd);
                        Vec2.negate(midHnd, midHnd);
                        Vec2.add(midHnd, prev.coord, midHnd);
                        Curve2.lerp13(midHnd, curr.coord, curr.rearHandle);

                        rel.set(curr.coord);
                     }

                     break;

                  case CUBIC_TO_ABS:

                     while ( dataItr.hasNext() ) {
                        prev = curr;
                        curr = new Knot2();
                        target.append(curr);

                        /* @formatter:off */
                        Knot2.fromSegCubic(
                           ParserSvg.parsef(dataItr.next(), 0.0f),
                           ParserSvg.parsef(dataItr.next(), 0.0f),
                           ParserSvg.parsef(dataItr.next(), 0.0f),
                           ParserSvg.parsef(dataItr.next(), 0.0f),
                           ParserSvg.parsef(dataItr.next(), 0.0f),
                           ParserSvg.parsef(dataItr.next(), 0.0f),
                           prev, curr);
                        /* @formatter:on */
                     }

                     rel.set(curr.coord);

                     break;

                  case CUBIC_TO_REL:

                     /* Add manually, do not use Knot2#translate . */
                     while ( dataItr.hasNext() ) {
                        prev = curr;
                        curr = new Knot2();
                        target.append(curr);

                        /* @formatter:off */
                        Knot2.fromSegCubic(
                           rel.x + ParserSvg.parsef(dataItr.next(), 0.0f),
                           rel.y + ParserSvg.parsef(dataItr.next(), 0.0f),
                           rel.x + ParserSvg.parsef(dataItr.next(), 0.0f),
                           rel.y + ParserSvg.parsef(dataItr.next(), 0.0f),
                           rel.x + ParserSvg.parsef(dataItr.next(), 0.0f),
                           rel.y + ParserSvg.parsef(dataItr.next(), 0.0f),
                           prev, curr);
                        /* @formatter:on */

                        rel.set(curr.coord);
                     }

                     break;

                  case REFLECT_CUBIC_ABS:

                     while ( dataItr.hasNext() ) {
                        prev = curr;
                        curr = new Knot2();
                        target.append(curr);

                        Knot2.fromSegCubicRefl(ParserSvg.parsef(dataItr.next(),
                           0.0f), ParserSvg.parsef(dataItr.next(), 0.0f),
                           ParserSvg.parsef(dataItr.next(), 0.0f), ParserSvg
                              .parsef(dataItr.next(), 0.0f), prev, curr);
                     }

                     rel.set(curr.coord);

                     break;

                  case REFLECT_CUBIC_REL:

                     /* Add manually, do not use Knot2#translate . */
                     while ( dataItr.hasNext() ) {
                        prev = curr;
                        curr = new Knot2();
                        target.append(curr);

                        /* @formatter:off */
                        Knot2.fromSegCubicRefl(
                           rel.x + ParserSvg.parsef(dataItr.next(), 0.0f),
                           rel.y + ParserSvg.parsef(dataItr.next(), 0.0f),
                           rel.x + ParserSvg.parsef(dataItr.next(), 0.0f),
                           rel.y + ParserSvg.parsef(dataItr.next(), 0.0f),
                           prev, curr);
                        /* @formatter:on */

                        rel.set(curr.coord);
                     }

                     break;

                  case ARC_TO_ABS:

                     /* @formatter:off */
                     while ( dataItr.hasNext() ) {
                        prev = curr;
                        target.appendAll(ParserSvg.parseArcTo(
                           prev,
                           ParserSvg.parsef(dataItr.next(), 0.0f),
                           ParserSvg.parsef(dataItr.next(), 0.0f),
                           ParserSvg.parseAngle(dataItr.next(), 0.0f),
                           ParserSvg.parseFlag(dataItr.next()),
                           ParserSvg.parseFlag(dataItr.next()),
                           ParserSvg.parsef(dataItr.next(), 0.0f),
                           ParserSvg.parsef(dataItr.next(), 0.0f)));
                        curr = target.getLast();
                     }
                     /* @formatter:on */

                     rel.set(curr.coord);

                     break;

                  case ARC_TO_REL:

                     /* @formatter:off */
                     while ( dataItr.hasNext() ) {
                        prev = curr;
                        target.appendAll(ParserSvg.parseArcTo(
                           prev,
                           ParserSvg.parsef(dataItr.next(), 0.0f),
                           ParserSvg.parsef(dataItr.next(), 0.0f),
                           ParserSvg.parseAngle(dataItr.next(), 0.0f),
                           ParserSvg.parseFlag(dataItr.next()),
                           ParserSvg.parseFlag(dataItr.next()),
                           rel.x + ParserSvg.parsef(dataItr.next(), 0.0f),
                           rel.y + ParserSvg.parsef(dataItr.next(), 0.0f)));
                        curr = target.getLast();

                        rel.set(curr.coord);
                     }
                     /* @formatter:on */

                     break;

                  default:

                     System.err.println(cmd + " unsupported path command.");

               } /* End command switch case. */

            } /* End path data loop. */

            /*
             * Append final curve recorded by while loop if it hasn't been
             * added; for multiple "sub-path"s which are not closed. As before,
             * final curve should have more than 2 knots.
             */
            if ( result.indexOf(target) < 0 && target.length() > 1 ) {
               result.add(target);
            }

            /* Deal with first and last knots in open versus closed loop. */
            final Iterator < Curve2 > resultItr = result.iterator();
            while ( resultItr.hasNext() ) {
               final Curve2 curve = resultItr.next();
               final Knot2 kn0 = curve.getFirst();
               final Knot2 kn1 = curve.getLast();

               if ( curve.closedLoop ) {
                  Knot2.fromSegLinear(kn0.coord, kn1, kn0);
               } else {
                  kn0.mirrorHandlesForward();
                  kn1.mirrorHandlesBackward();
               }
            } /* End while loop to fix knots for closed loops. */

         } /* End path data null check. */
      } /* End attributes null check. */

      return result;

   }

   /**
    * Parses a polygon or poly-line node.
    *
    * @param polygonNode the polygon
    * @param target      the output curve
    *
    * @return the curve
    */
   protected static Curve2 parsePoly ( final Node polygonNode,
      final Curve2 target ) {

      final NamedNodeMap attributes = polygonNode.getAttributes();
      if ( attributes != null ) {

         /* Close loop if the node is a polygon. */
         final String name = polygonNode.getNodeName();
         if ( name.equals("polygon") ) {
            target.closedLoop = true;
         } else {
            target.closedLoop = false;
         }

         final Node ptsNode = attributes.getNamedItem("points");
         final String ptsSt = ptsNode != null ? ptsNode.getNodeValue() : "0,0";
         final ArrayList < String > coords = new ArrayList <>(8);
         ParserSvg.segmentChars(ptsSt.toCharArray(), 0, ptsSt.length(), coords);

         /* x, y pairs are flattened into a 1D array, so use half length. */
         target.resize(coords.size() / 2);

         final Iterator < Knot2 > knItr = target.iterator();
         final Iterator < String > stItr = coords.iterator();
         final Knot2 first = knItr.next();
         first.coord.set(ParserSvg.parsef(stItr.next(), 0.0f), ParserSvg.parsef(
            stItr.next(), 0.0f));

         Knot2 prev = first;
         while ( knItr.hasNext() ) {
            final Knot2 curr = knItr.next();
            Knot2.fromSegLinear(ParserSvg.parsef(stItr.next(), 0.0f), ParserSvg
               .parsef(stItr.next(), 0.0f), prev, curr);
            prev = curr;
         }

         if ( target.closedLoop ) {
            Knot2.fromSegLinear(first.coord, prev, first);
         } else {
            first.mirrorHandlesForward();
            prev.mirrorHandlesBackward();
         }
      }
      return target;
   }

   /**
    * Parses a SVG node and returns a Curve2 representing a rectangle.
    *
    * @param rectNode the rectangle node
    * @param target   the output curve
    *
    * @return the rectangle curve
    */
   protected static Curve2 parseRect ( final Node rectNode,
      final Curve2 target ) {

      final NamedNodeMap attributes = rectNode.getAttributes();
      if ( attributes != null ) {

         /* Search for property nodes. May return null. */
         final Node xNode = attributes.getNamedItem("x");
         final Node yNode = attributes.getNamedItem("y");
         final Node wNode = attributes.getNamedItem("width");
         final Node hNode = attributes.getNamedItem("height");

         /* One or other of the rounding tags may be missing. */
         Node rxNode = attributes.getNamedItem("rx");
         Node ryNode = attributes.getNamedItem("ry");
         if ( ryNode != null && rxNode == null ) { rxNode = ryNode; }
         if ( rxNode != null && ryNode == null ) { ryNode = rxNode; }

         /* Acquire text content from the node if it exists. */
         final String xStr = xNode != null ? xNode.getNodeValue() : "0";
         final String yStr = yNode != null ? yNode.getNodeValue() : "0";
         final String wStr = wNode != null ? wNode.getNodeValue() : "1";
         final String hStr = hNode != null ? hNode.getNodeValue() : "1";
         final String rxStr = rxNode != null ? rxNode.getNodeValue() : "0";
         final String ryStr = ryNode != null ? ryNode.getNodeValue() : "0";

         /* Parse string or default. */
         final float x = ParserSvg.parsef(xStr, 0.0f);
         final float y = ParserSvg.parsef(yStr, 0.0f);
         final float w = ParserSvg.parsef(wStr, 1.0f);
         final float h = ParserSvg.parsef(hStr, 1.0f);
         final float rx = ParserSvg.parsef(rxStr, 0.0f);
         final float ry = ParserSvg.parsef(ryStr, 0.0f);

         /*
          * Corner rounding differs between APIs, so average horizontal and
          * vertical rounding.
          */
         final float rAvg = ( rx + ry ) * 0.5f;
         if ( rAvg < IUtils.EPSILON ) {
            Curve2.rect(x, y, x + w, y + h, target);
         } else {
            Curve2.rect(x, y, x + w, y + h, rAvg, target);
         }
      }
      return target;
   }

   /**
    * Parses an SVG node containing transform data and converts it to a 3x3
    * matrix. The delta matrix contains individual transform commands such as
    * "translate", "rotate" and "scale."
    *
    * @param trNode the transform node
    * @param target the output matrix
    * @param delta  a temporary matrix
    *
    * @return the matrix
    */
   protected static Mat3 parseTransform ( final Node trNode, final Mat3 target,
      final Mat3 delta ) {

      final char[] chars = trNode.getNodeValue().toCharArray();
      final int charsLen = chars.length;
      final ArrayList < TransformData > transforms = new ArrayList <>(4);
      TransformData currData = null;
      int parClsIdx = -1;

      /* Parse transform commands. */
      for ( int i = 0; i < charsLen; ++i ) {
         final char c = chars[i];
         if ( c == '(' ) {
            final String str = new String(chars, parClsIdx + 1, parClsIdx < 0
               ? i : i - parClsIdx - 1);
            final SvgTransformCmd cmd = SvgTransformCmd.fromString(str);
            currData = new TransformData(cmd, i + 1, charsLen);
            transforms.add(currData);
         } else if ( c == ')' ) {
            parClsIdx = i;
            currData.ubDat = i;
         }
      }

      final Iterator < TransformData > trItr = transforms.iterator();
      while ( trItr.hasNext() ) {

         final TransformData entry = trItr.next();
         ParserSvg.segmentChars(chars, entry.lbDat, entry.ubDat, entry.data);
         final SvgTransformCmd cmd = entry.cmd;
         final Iterator < String > dtItr = entry.data.iterator();

         switch ( cmd ) {

            case MATRIX:

               /* Column major order. */
               final String m00 = dtItr.next();
               final String m10 = dtItr.next();
               final String m01 = dtItr.next();
               final String m11 = dtItr.next();
               final String m02 = dtItr.next();
               final String m12 = dtItr.next();

               /* @formatter:off */
               delta.set(
                  ParserSvg.parsef(m00, 1.0f),
                  ParserSvg.parsef(m01, 0.0f),
                  ParserSvg.parsef(m02, 0.0f),
                  ParserSvg.parsef(m10, 0.0f),
                  ParserSvg.parsef(m11, 1.0f),
                  ParserSvg.parsef(m12, 0.0f),
                  0.0f, 0.0f, 1.0f);
               Mat3.mul(target, delta, target);
               /* @formatter:on */

               break;

            case ROTATE:

               final String ang = dtItr.next();
               final String xPivStr = dtItr.hasNext() ? dtItr.next() : "0";
               final String yPivStr = dtItr.hasNext() ? dtItr.next() : "0";
               final float xPiv = ParserSvg.parsef(xPivStr, 0.0f);
               final float yPiv = ParserSvg.parsef(yPivStr, 0.0f);
               final Vec2 pivot = new Vec2(xPiv, yPiv);

               Mat3.fromTranslation(pivot, delta);
               Mat3.mul(target, delta, target);

               Mat3.fromRotZ(ParserSvg.parseAngle(ang, 0.0f), delta);
               Mat3.mul(target, delta, target);

               Mat3.fromTranslation(Vec2.negate(pivot, pivot), delta);
               Mat3.mul(target, delta, target);

               break;

            case SCALE:

               final String scx = dtItr.next();
               final String scy = dtItr.hasNext() ? dtItr.next() : scx;
               Mat3.fromScale(ParserSvg.parsef(scx, 1.0f), ParserSvg.parsef(scy,
                  1.0f), delta);
               Mat3.mul(target, delta, target);

               break;

            case SKEW_X:

               Mat3.fromSkewX(ParserSvg.parseAngle(dtItr.next(), 0.0f), delta);
               Mat3.mul(target, delta, target);

               break;

            case SKEW_Y:

               Mat3.fromSkewY(ParserSvg.parseAngle(dtItr.next(), 0.0f), delta);
               Mat3.mul(target, delta, target);

               break;

            case TRANSLATE:

               final String tx = dtItr.next();
               final String ty = dtItr.hasNext() ? dtItr.next() : "0";
               Mat3.fromTranslation(ParserSvg.parsef(tx, 0.0f), ParserSvg
                  .parsef(ty, 0.0f), delta);
               Mat3.mul(target, delta, target);

               break;

            default:
         }
      }

      return target;
   }

   /**
    * Splits an array of characters into Strings based on commas, spaces and
    * negative signs.
    *
    * @param chars  the characters
    * @param start  the start index
    * @param end    the end index
    * @param target the output list
    *
    * @return the list
    */
   protected static ArrayList < String > segmentChars ( final char[] chars,
      final int start, final int end, final ArrayList < String > target ) {

      /*
       * In optimized SVGs, a negative sign may be a delimiter between
       * coordinates. A decimal point may also be a delimiter; see
       * https://discourse.processing.org/t/why-arent-my-svg-images-rendering-
       * properly-in-processing/29548 .
       */

      int count = 0;
      boolean decimalDelim = false;
      for ( int i = start; i < end; ++i ) {
         final char c = chars[i];
         if ( c == ' ' || c == ',' ) {
            final String str = new String(chars, i - count, count).trim();
            if ( !str.isEmpty() ) { target.add(str); }
            count = 0;
            decimalDelim = false;
         } else if ( c == '-' || c == '+' ) {
            final String str = new String(chars, i - count, count).trim();
            if ( !str.isEmpty() ) { target.add(str); }
            count = 1;
            decimalDelim = false;
         } else if ( c == '.' ) {
            if ( decimalDelim ) {
               final String str = new String(chars, i - count, count).trim();
               if ( !str.isEmpty() ) { target.add(str); }
               count = 1;
               decimalDelim = false;
            } else {
               decimalDelim = true;
               ++count;
            }
         } else {
            ++count;
         }
      }

      final String str = new String(chars, end - count, count);
      if ( !str.isEmpty() ) { target.add(str); }

      return target;
   }

   /**
    * An internal helper class to associate viable path commands at an index
    * in a String with readable data.
    */
   protected static class PathData {

      /**
       * The path command.
       */
      public SvgPathCmd cmd;

      /**
       * The parsed data affiliated with the command.
       */
      public final ArrayList < String > data;

      /**
       * Lower bounds index, inclusive, for data chunk.
       */
      public int lbDat = 0;

      /**
       * Upper bounds index, exclusive, for data chunk.
       */
      public int ubDat = Integer.MAX_VALUE;

      /**
       * Constructs path data with a command and index.
       *
       * @param cmd   the command
       * @param lbDat the index
       * @param ubDat the upper bound index
       */
      public PathData ( final SvgPathCmd cmd, final int lbDat,
         final int ubDat ) {

         this(cmd, lbDat, ubDat, new ArrayList <>(cmd.getDataCount()));
      }

      /**
       * Constructs path data with a command, index and array of data.
       *
       * @param cmd   the command
       * @param lbDat the lower bound index
       * @param ubDat the upper bound index
       * @param data  the data
       */
      public PathData ( final SvgPathCmd cmd, final int lbDat, final int ubDat,
         final ArrayList < String > data ) {

         this.cmd = cmd;
         this.lbDat = lbDat;
         this.ubDat = ubDat;
         this.data = data;
      }

      /**
       * Returns a string representation of this path data.
       */
      @Override
      public String toString ( ) {

         final StringBuilder sb = new StringBuilder(512);
         sb.append("{ cmd: ");
         sb.append(this.cmd.toString());
         sb.append(", lbDat: ");
         sb.append(Utils.toPadded(this.lbDat, 0));
         sb.append(", ubDat: ");
         sb.append(Utils.toPadded(this.ubDat, 0));
         sb.append(", data: [ ");

         final Iterator < String > itr = this.data.iterator();
         while ( itr.hasNext() ) {
            sb.append(itr.next());
            if ( itr.hasNext() ) { sb.append(',').append(' '); }
         }

         sb.append(" ] }");
         return sb.toString();
      }

   }

   /**
    * An internal helper class to associate viable transform commands at an
    * index in a String with readable data.
    */
   protected static class TransformData {

      /**
       * The transform command.
       */
      public SvgTransformCmd cmd;

      /**
       * The list of data.
       */
      public final ArrayList < String > data;

      /**
       * Lower bounds index, inclusive, for data chunk.
       */
      public int lbDat = 0;

      /**
       * Upper bounds index, exclusive, for data chunk.
       */
      public int ubDat = Integer.MAX_VALUE;

      /**
       * Constructs transform data with a command and index.
       *
       * @param cmd   the command
       * @param lbDat the index
       * @param ubDat the upper bound index
       */
      public TransformData ( final SvgTransformCmd cmd, final int lbDat,
         final int ubDat ) {

         this(cmd, lbDat, ubDat, new ArrayList <>(cmd.getMaxDataCount()));
      }

      /**
       * Constructs transform data with a command, index and array of data.
       *
       * @param cmd   the command
       * @param lbDat the lower bound index
       * @param ubDat the upper bound index
       * @param data  the data
       */
      public TransformData ( final SvgTransformCmd cmd, final int lbDat,
         final int ubDat, final ArrayList < String > data ) {

         this.cmd = cmd;
         this.lbDat = lbDat;
         this.ubDat = ubDat;
         this.data = data;
      }

      /**
       * Returns a string representation of this transform data.
       */
      @Override
      public String toString ( ) {

         final StringBuilder sb = new StringBuilder(512);
         sb.append("{ cmd: ");
         sb.append(this.cmd.toString());
         sb.append(", lbDat: ");
         sb.append(Utils.toPadded(this.lbDat, 0));
         sb.append(", ubDat: ");
         sb.append(Utils.toPadded(this.ubDat, 0));
         sb.append(", data: [ ");

         final Iterator < String > itr = this.data.iterator();
         while ( itr.hasNext() ) {
            sb.append(itr.next());
            if ( itr.hasNext() ) { sb.append(',').append(' '); }
         }

         sb.append(" ] }");
         return sb.toString();
      }

   }

}
